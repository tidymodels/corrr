---
title: "corrr"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

corrr is a package for exploring **corr**elation matrices in **R**. It makes it possible to easily perform routine tasks when exploring correlation matrices such as comparing only some variables against others, or arranging the matrix in terms of the strength of the correlations, and so on. `corrr` also provides visualisation methods for extracting useful information such as variable clustering and latent dimensionality.

`corrr` is intended to be used for exploration and visualisation, NOT for statistical modeling (obtaining p values, factor analysis, etc.).

You can install:

- the latest development version from github with

```{r install_git, eval = FALSE}
if (packageVersion("devtools") < 1.6) {
  install.packages("devtools")
}
devtools::install_github("drsimonj/corrr")
```

## Getting Started

`corrr` centers around the `correlate()` function, which returns a correlation matrix generated by `stats::cor()`, but in a format of the following:

- A tibble::data_frame
- An additional class, "cor_df"
- A "rowname" column
- Standardised variances (the matrix diagonal) set to missing values (`NA`) so they can be ignored in calculations.

Another small adjustment is that `correlate()` uses pairwise deletion by default.

```{r}
library(MASS)
library(corrr)
set.seed(1)

# Simulate three columns correlating about .7 with each other
mu <- rep(0, 3)
Sigma <- matrix(.7, nrow = 3, ncol = 3) + diag(3)*.3
seven <- mvrnorm(n = 1000, mu = mu, Sigma = Sigma)

# Simulate three columns correlating about .4 with each other
mu <- rep(0, 3)
Sigma <- matrix(.4, nrow = 3, ncol = 3) + diag(3)*.6
four <- mvrnorm(n = 1000, mu = mu, Sigma = Sigma)

# Bind together
d <- cbind(seven, four)
colnames(d) <- paste0("v", 1:ncol(d))

# Insert some missing values
d[sample(1:nrow(d), 100, replace = TRUE), 1] <- NA
d[sample(1:nrow(d), 200, replace = TRUE), 5] <- NA

# Correlate
x <- correlate(d)
class(x)
x
```

## Correlation matrices as Correlation Data Frames (cor_df)

By using the data_frame structure, we can more easily leverage functions from packages like `dplyr`, `tidyr`, `ggplot2`, and so on. Below are some useful examples:

```{r, message = FALSE, warning = FALSE}
library(dplyr)

# Select a subset of variables by column
x %>% select(rowname, v1, v2)

# Select a subset of variables by rows (using filter)
x %>% filter(rowname %in% c("v1", "v2"))

# Select columns and rows
x %>%
  filter(rowname %in% paste0("v", 4:6)) %>%
  select(rowname, v1:v3)

# Filter rows by correlation size
x %>% filter(v1 > .6)

# Calculate the mean correlation for each variable
x %>%
  select(-rowname) %>%
  summarise_each(funs(mean(., na.rm = TRUE))) %>%
  round(2)

```

## The Functions of corrr

The primary corrr functions do one of three major tasks with a `cor_df`:

Change the internal values:

- shave()
- rearrange()

Reshape the values:

- focus()
- stretch()

Generate output/visualsations:

- rplot()

## Examples

Following are some examples of combining corrr functions in a single pipeline:

```{r combination, warning = FALSE, fig.height = 4, fig.width = 5}
datasets::mtcars %>%
  correlate() %>%    # Create correlation data frame (cor_df)
  focus(-cyl, -vs, rows = TRUE) %>%  # Focus on cor_df without 'cyl' and 'vs'
  rearrange(method = "HC", absolute = FALSE) %>%  # arrange by correlations
  shave() %>%  # Shave off the upper triangle for a clean plot
  rplot()  # Plot the results
```

## Reshaping

### focus()

`focus()` helps to focus in on a section of a `cor_df`. You use it similarly to selecting columns with `dplyr::select()`, but rows are also affected. As arguments, it takes your `cor_df`, expressions you would use in `select()`, and an optional boolean argument `rows`, indicating whether to keep the selected, or all other variables (default), in the rows. Here are some examples of using `focus()`:

```{r focus}
# select v1 and v2 to stay in the columns but not rows
x %>% focus(v1, v2)

# Keep in columns and rows (drop all others)
x %>% focus(v1, v2, rows = TRUE)

# Or put these variables into the rows by dropping from columns
x %>% focus(-v1, -v2)

# And can use any dplyr::select() expressions
x %>% focus(num_range("v", 1:3))
```

### stretch()

`stretch()` converts your `cor_df` into a long-format data frame. It behaves similarly to `tidyr::gather()`. As arguments, it takes your `correlate()` correlation matrix, expressions you would use in `dplyr::select()` (as above), and some optional boolean arguments. The result is a three-column data frame with columns `x` and `y` storing variable names, and `r`, storing the correlation. Here are some examples of using `stretch()`:

```{r stretch}
# Convert all to long format
x %>% stretch(everything())

# Select certain variables to convert to long format
x %>% stretch(v1, v3, v4)

# Drop missing values (the diagonal by default) using na_omit = TRUE
x %>% stretch(num_range("v", 4:6), na_omit = TRUE)

# Or combine with shave() to set all duplicates to missing first
# and then omit (to retain each correlation just once)
x %>% shave() %>% stretch(everything(), na_omit = TRUE)

```

## Output/Visualisation

`corrr` provides a number of methods for visualising a correlation matrix. Below are some examples.

`rplot()` creates a visual of the entire correlate() matrix. It uses the package `ggplot2` to produce a point plot with colouring, size and alpha to support visualisation.

```{r rplot, warning = FALSE, fig.height = 4, fig.width = 5}
mtcars %>% correlate() %>% rplot()
```

This is particularly useful if `rearrange()` is used first, as it rearranges the correlations to group highly correlated variables together. Some examples combining this and the above:

```{r rplot_arranged, warning = FALSE, fig.height = 4, fig.width = 5}
# Default settings
mtcars %>% correlate() %>% rearrange() %>% rplot()

# Using hierarchical clustering (method = "HC") and treating negative and
# positive correlations as distant (absolute = FALSE)
mtcars %>% correlate() %>% rearrange(method = "HC", absolute = FALSE) %>% rplot()


# As with stretch(), use shave() to screen out one of the triangles
mtcars %>% correlate() %>% rearrange() %>% shave() %>% rplot()
```
